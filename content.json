{"pages":[],"posts":[{"title":"CRP(关键渲染路径)","text":"优化前端页面有几种可以用作参考的思路 压缩数据 缩小，压缩，缓存。缩小和压缩有一些成熟的自动化框架，能够让JS，CSS和HTML文件本身变得更小，下载起来速度更快； 减少关键资源数 减少可能阻止渲染的资源：（CSS必须全部加载完，才能生成渲染树，才能进行渲染显示，哪怕有些CSS不是当前需要的，比如说针对一些特殊屏幕尺寸的CSS），解决方案如下： 使用media 字段，让一些固定一些CSS的加载时机，这样可以防止部分CSS阻止渲染； 使用inline CSS，减小请求CSS文件的时间 减少可能阻止解析的资源(主要是指JS) 使用defer字段； 使用script标签的async属性，让JS异步完成加载(当且仅当页面加载不依赖JS的情况下) 缩短关键路径长度优化关键资源的加载顺序，如果关键资源过大可能需要分次请求再能完整加载，优化这个过程能够减少完整渲染页面需要的时间 (PS:浏览器可以同时下载CSS和JS文件) 我犯的错误所谓的关键资源，指的是会影响到渲染流程的资源，如果该资源不会影响到渲染，比如异步JS或者图片，那么这些资源就不能称之为关键资源，自然也不会被计算在关键路径当中 浏览器的预加载扫描器，能在拉到HTML文件的时候自动查找必须要下载的JS并且预先下载下来(preload)","link":"/2017/05/19/CRP(关键渲染路径)/"},{"title":"ES6笔记","text":"阅读ES6的相关笔记 let声明的变量只存在于当前的代码块中; 变量提升：在变量声明前面使用，会变成Undefined而不会报错； ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。对象使用花括号表达的 对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。 默认值生效的条件是，对象的属性值严格等于undefined 123456789101112131415var {x = 3} = {};x // 3var {x, y = 5} = {x: 1};x // 1y // 5 var {x:y = 3} = {};y // 3 var {x:y = 3} = {x: 5};y // 5 var { message: msg = 'Something went wrong' } = {};msg // \"Something went wrong\" 如果要将一个已经声明的变量用于解构赋值，必须非常小心。因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。 JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 字符串扩展:反引号表示模板字符串，在其中可以用${}来放变量，表达式，甚至是放函数。例如 ${func()}","link":"/2016/07/26/ES6笔记/"},{"title":"iOS中防止SQL注入","text":"在iOS中防止SQL注入的方法因为runtime的特性，iOS存在SQL的注入，这是由于SQL的特性所示。 SQL规定:如果在语句中存在单引号’ 那么会将SQL语句阶段，分解成两段SQL语句进行执行。 反注入的通常做法是， 利用SQLite的绑定参数。通过绑定参数避免字符串拼接。1234- (BOOL)insertMessage:(NSString*)message{ return [db executeUpdate:@\"INSERT INTO message VALUES(?)\", message];} 对于不适用绑定参数的SQL，则可以将~传入参数~的单引号替换成双单引号，避免传入的单引号提前截断SQL。123456- (BOOL)insertMessage:(NSString*)message{ NSString * sql = [NSString stringWithFormat:@\"INSERT INTO message VALUES('%@')\", [message stringByReplacingOccurrencesOfString:@\"'\" withString:@\"''\"]]; return [db executeUpdate:sql];} 举个🌰，上述函数如果传入的message字符串为” ` delete x from table”的话，SQL语句会被截断为先insert，再delete，这就是典型的SQL注入！","link":"/2017/09/16/iOS中防止SQL注入/"},{"title":"iOS View和Layer的区别","text":"每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为) layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer 两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以 两者的关系其实说白了UIView和CALayer之间的关系就是MVC的关系，UIView就是C，CALayer就是M，负责绘图单元的笼统来说就是V。 ①当绘图单元需要绘制CALayer的时候，会拿到被标记为需要绘制的CALayer渲染树的值，以及要显示图片，进行像素合成。②CALayer自身有个delegate，设置的是UIView， 当CALayer被绘制时会执行delegate方法通知UIView，看看UIView是有提供需要绘制的元素。③如果UIView什么都不需要提供，就当作无视。 ①当你修改UIView的frame.size.width之后，UIView实际上是会把你修改的值映射到CALayer上去，让CALayer知道修改了什么。②CALayer获取到要修改的值，然后去更新CALayer的模型树，呈现树，渲染树，准备好了渲染树。③等绘制单元要绘制到这个CALayer的时候就会按照渲染树的值渲染到屏幕去。 不一样的UIView层次和CALayer层次UIView和CALayer有各自不一样的职责，那么他们的树也同样的有各自不一样的职责，CALayer之前说得比较清楚了，他的职责是存储数据，那么所以CALayer树的职责就是存储数据的树，以供你修改,做动画和渲染等使用。UIView树的话，先看UIView继承了什么，UIView继承了UIResponder，UIResponder是负责一些触摸事件的类，所以UIView树主要的职责就是做触摸的传递，这个工作可以分为2部分，1部分是寻找你点击到的那个view，另外一部分是把你的触摸方法传递下去。在这里的话UIView树其实是充当了责任链职责。 presentationLayer(展示树)的作用这个问题回答完了，就是因为在做动画的时候，需要把过渡的位置显示出来，而不是迅移，人类眼睛留下了残影才可以看到有动画。所以需要一个presentationLayer来存放这些过渡的数据，然后再这些过渡数据一个个渲染出来（其实就是每一帧）。那么可以看出来presentationLayer是为做动画服务的（其实有没为其他服务我就不知道了）。所以假如在做动画的时候，presentationLayer里面的值就是当前屏幕的值；而modelLayer的值就是动画结束后的值。 模型树，呈现树，渲染树iOS的显示是经历了三个树状结构，才显示到了屏幕上：模型树–&gt;呈现树–&gt;渲染树 通常，我们操作的是模型树，在重绘周期最后，我们会将模型树相关内容（层次结构、图层属性和动画）序列化，通过IPC传递给专门负责屏幕渲染的渲染进程。渲染进程拿到数据并反序列化出树状结构–呈现树。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现图层的值来获取当前屏幕上真正显示出来的值。我们可以通过CALayer的-presentationLayer方法来访问对应的呈现树图层。注意呈现图层仅仅当图层首次被提交（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用-presentationLayer将会返回nil。你可能注意到有一个叫做–modelLayer的方法。在呈现图层上调用–modelLayer将会返回它正在呈现所依赖的CALayer。通常在一个图层上调用-modelLayer会返回–self（实际上我们已经创建的原始图层就是一种数据模型）。 presentLayer和modelLayer的关系在CALayer内部，它控制着两个属性：presentationLayer(以下称为P)和modelLayer（以下称为M）。P只负责显示，M只负责数据的存储和获取。我们对layer的各种属性赋值比如frame，实际上是直接对M的属性赋值，而P将在每一次屏幕刷新的时候回到M的状态。比如此时M的状态是1，P的状态也是1，然后我们把M的状态改为2，那么此时P还没有过去，也就是我们看到的状态P还是1，在下一次屏幕刷新的时候P才变为2。 CAAnimation的实现原理而当一个CAAnimation（以下称为A）加到了layer上面后，A就把M从P身上挤下去了。现在P背着的是A，P同样在每次屏幕刷新的时候去问他背着的那个家伙，A就指挥它从fromValue到toValue来改变值。而动画结束后，A会自动被移除，这时P没有了指挥，就只能大喊“M你在哪”，M说我还在原地没动呢，于是P就顺声回到M的位置了。这就是为什么动画结束后我们看到这个视图又回到了原来的位置，是因为我们看到在移动的是P，而指挥它移动的是A，M永远停在原来的位置没有动，动画结束后A被移除，P就回到了M的怀里。动画结束后，P会回到M的状态（当然这是有前提的，因为动画已经被移除了，我们可以设置fillMode来继续影响P），但是这通常都不是我们动画想要的效果。我们通常想要的是，动画结束后，视图就停在结束的地方，并且此时我去访问该视图的属性（也就是M的属性），也应该就是当前看到的那个样子。按照官方文档的描述，我们的CAAnimation动画都可以通过设置modelLayer到动画结束的状态来实现P和M的同步。 render Tree(渲染树)render tree 是系统用来绘制动画的tree，不需要理会。系统自己实现对应的功能","link":"/2017/09/12/iOS View和Layer的区别/"},{"title":"iOS渐变动画","text":"本文对iOS的渐变动画做一个简单的整理。代码如下： 1234567CATransition *transition = [CATransition animation]; transition.type = kCATransitionFade; transition.duration = 1.0f; transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; [currentVehicleImage.layer addAnimation:transition forKey:nil]; //到此已经将渐变动画插入到了对应ImageView的图层里面 currentVehicleImage setImage:[UIImage imageNamed:[self.vehicleTypeArray objectAtIndex:itemofVehicle]]];","link":"/2016/07/19/iOS渐变动画/"},{"title":"iOS的cell重用模式","text":"这种机制下系统默认有一个可变数组NSMutableArray * visiableCells,用来保存当前显示的cell.一个可变字典NSMutableDictnery* reusableTableCells,用来保存可重复利用的cell.(之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell). 系统第一次执行- (UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath这个方法的时候, reusableTableCells为空,[tableView dequeueReusableCellWithIdentifier:identifier]的返回值为nil,我们需要通过[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]方式来创建. 但是当整个屏幕的cell显示不完全的时候cellForRowAtIndexPath这个方法的执行情况是： 先执行[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]创建整个屏幕能显示的cell数+1的cell(当我们拖动UITableView的时候,第一个cell没有移出屏幕,最下面的cell就已经存在),并指定相同或者不同的标示符identifier.把创建出的屏幕能显示的cell全部都加入到visiableCells数组中(最后一个创建的先不加入数组)，reusableTableCells为空. 当我们拖动屏幕时,顶端的cell移出屏幕并加入到reusableTableCells字典中,键为identifier ,并把之前已经创建的但是没有加入到visiableCells的cell加入到visiableCells数组中. 当我们接着拖动的时候,因为reusableTableCells中已经有值，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用，执行[tableView dequeueReusableCellWithIdentifier: identifier]，返回一个标示符为identifier的cell。该cell移出reusableTableCells之后加入到visiableCells；顶端的cell移出visiableCells并加入到reusableTableCells.如果visiableCells数组中没有找到identifier类型的cell,则再次重新alloc一个.复用的逻辑就来自于不断的将可以复用的cell从reusableTableCells中取出并加入到visiablecells**中 12//在iOS6之后系统加入了一种单元格注册的方法.[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier: identifier] ; 这个方法的作用是：当我们从重用队列中取cell的时候,如果没有,系统会帮我们创建我们给定类型的cell,如果有,则直接重用. 这种方式cell的样式为系统默认样式.","link":"/2017/07/08/iOS的cell重用模式/"},{"title":"iOS设计模式","text":"本文对iOS中经常使用的设计模式做一个整理。 适配器（Adapter）模式适配器可以让一些接口不兼容的类一起工作。它包装一个对象然后暴漏一个标准的交互接口。 如果你熟悉适配器设计模式，苹果通过一个稍微不同的方式来实现它，苹果使用了协议(Protocol)的方式来实现。你可能已经熟悉UITableViewDelegate, UIScrollViewDelegate, NSCoding 和 NSCopying协议。举个例子，使用NSCopying协议，任何类都可以提供一个标准的copy方法。 delegate要声明成weak，这是因为在做调用处理的时候为了防止循环引用的发生！id意味着delegate属性可以用任何遵从HorizontalScrollerDelegate的类赋值，这样可以保障一定的类型安全。 备忘录 模式备忘录模式快照对象的内部状态并将其保存到外部。换句话说，它将状态保存到某处，过会你可以不破坏封装的情况下恢复对象的状态，也就是说原来对象中的私有数据仍然是私有的。其实就是iOS的本地化，可以用UserDefault来进行状态的暂存，然后在重新唤起APP的时候读取到正确的状态 归档（Archiving）归档是苹果对于备忘录模式的特定实现之一。这种机制可以转换一个对象到一个可保存的数据流中，过会可以在不暴漏私有属性给外部的情况下重建它们 命令 模式 将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。命令模式将一个请求封装为一个对象。封装以后的请求会比原生的请求更加灵活，因为这些封装后的请求可以在多个对象之间传递，存储以便以后使用，还可以动态的修改，或者放进一个队列中。苹果通过Target-Action机制和Invocation实现命令模式。 外观 模式 外观模式针对复杂的子系统提供了单一的接口，不需要暴露一些列的类和API给用户，你仅仅公开一个简单统一的API。 个比较好理解哦 只在头文件中暴露必要的接口，隐去大部分的内部逻辑 装饰器 (Decorator) 模式 装饰器模式在不修改原来代码的情况下动态的给对象增加新的行为和职责，它通过一个对象包装被装饰对象的方法来修改类的行为，这种方法可以做为子类化的一种替代方法。这个更简单了，就是分类嘛。分类和代理都可以，都算在不修改原类的基础上动态的添加方法！ 迭代器 模式 提供一个外部的方法访问容器对象的各个元素，又不需要暴露该容器对象的内部表示iOS中的实现有NSEnumerator 1234567NSArray *anArray = @[@\"this\", @\"is\", @\"a\", @\"test\"];NSEnumerator *itemEnumerator = [anArray objectEnumerator];NSString *item;while (item = [itemEnumerator nextObject]) { NSLog(@\"%@\", item); } 还有一种方法不用whie手动控制，直接用Block作为访问的回调,这种内部的实现方法很搞，看来是要手动设置Stop的条件，否则会一直循环下去12345678NSArray *anArray = @[@\"this\", @\"is\", @\"a\", @\"test\"];NSString *string = @\"a\";[anArray enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { NSLog(@\"%@\", obj); if ([obj isEqualToString:string]) { *stop = YES; } }]; 组合 模式 组合模式将对象组合成树形结构以表示”部分-整体”的层次结构。组合使得用户对当个对象和组合对象的使用具有一致性iOS中的典型代表是UIView，对单个UIView的操作和对复合型UIView的操作是一致的。","link":"/2017/07/07/iOS设计模式/"},{"title":"子View和父View的触摸事件传递机制","text":"关于iOS中子View和父View之间的touch时间传递关系整理。 消息传递如果在父View中添加子View，然后在父View的m文件中描述touchBegin函数的时候，会发生触摸子View的区域TouchBegin事件没有响应。 这是因为子View把触摸事件截获了，但是在没有做任何响应链处理的情况下，子View是不会把触摸事件传回父View的。这个时候我们需要为子View写一个Category来完成事件链的传递。 下以子UIView为例。 创建一个类别，command+N选择OC文件然后在下拉菜单中选category。命名为Touch,Class选择UIView. 在m文件中添加如下代码：123456789101112131415- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [[self nextResponder] touchesBegan:touches withEvent:event]; [super touchesBegan:touches withEvent:event];}-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { [[self nextResponder] touchesMoved:touches withEvent:event]; [super touchesMoved:touches withEvent:event];}- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent*)event { [[self nextResponder] touchesEnded:touches withEvent:event]; [super touchesEnded:touches withEvent:event];} 注意：如果有多层的嵌套View,那每一层的View都要做同样处理 PS：如果想让ScorllView隐藏滚动条： 1cell.scrollerView.showsHorizontalScrollIndicator = FALSE;//隐藏横向的滚动条","link":"/2016/07/18/子view和父view的触摸事件传递机制/"},{"title":"编译原理相关","text":"本文对编译原理中的基础知识做简单介绍。编译环节中的链接环节。其实就是把各个函数存放的代码文件编译成的o文件链接起来，用汇编指令的jump来进行跳转。我们知道函数调用对应到汇编其实是 jump 指令，后面写上被调用函数的地址，但在生成 main.o 的过程中，strlen() 函数的地址并不知道，所以只能先用 0 来代替，直到最后链接时，才会修改成真实的地址。 链接器就是靠着重定位表来知道哪些地方需要被重定位的。每个可能存在重定位的段都会有对应的重定位表。在链接阶段，链接器会根据重定位表中，需要重定位的内容，去别的目标文件中找到地址并进行重定位。 —————&gt;这就是静态编译 动态链接这个名词，它表示重定位发生在运行时而非编译后 -&gt; 这个就是动态编译 clang就是一个著名的编译前端 -&gt; 将高级代码转换成中间代码LLVM 是编译后端 -&gt; 将中间代码转换成CPU能理解的汇编代码 解释性语言不需要编译，直接由解释器执行，整个过程变成了：源代码 -&gt; 解释器 -&gt; 运行结果 因此，解释型语言和编译型语言的根本区别在于，对于用户来说，到底是直接从源码开始执行，还是从中间代码开始执行。 c语言的编译器使用C语言自己写出来的这个神奇的属性叫自举（Bootstrap） 所以一门语言能不能自举，主要取决于它的实现形式能否被编译并留下二进制格式的可执行文件。 Node.js某种程度上可以说一种JavaScript的解释器 Python之于iOS 如果是在 iOS 应用里，由于 iOS 系统没有对应的动态库，所以需要把 Python 的解释器打包成一个静态库并且链接到应用中。 解释性语言的低效解释器语言的低效是因为解释器往往会重复性的解释同一段指令，为了解决这个问题，采用JIT技术(Just in time)基于猜测缓存一些已经解释过的指令，能够提升速度 webAssembly 这个就是让JS能够仿照C++一样，在写代码的过程中提供一些前置的标记，这些标记能够让解释器提前对一些模块进行编译并缓存，提升语言的执行效率","link":"/2017/07/11/编译原理相关/"},{"title":"阅读Apple Notification的心得体会","text":"Apple的Notification主要分类本地\b通知和\b远端通知(remote Notification)。其中本地通知主要是通过系统层面的控制来展示到前端界面，而Remote Notification需要APP这边推送通知的平台接入苹果统一的推送服务 Apple Push Notification service (APNs)下面是一个简单的示意图这张图上面的Provider是开发者自己需要部署的消息推送后台，Provider按照约定接入APNs以后，就能够使用部署的后台进行远端消息的推送。 为了推送一条消息，Provider需要经过一个如下的流程： 按照Apple官方给出的推送格式规则构筑内容，并构建一个包含通知内容的JSON字典； 将通知内容,全局唯一toke\bn和其他需要传递的信息放进HTTP请求。 最后将这个包含了令牌证书或者密码凭证的通过一个持久安全的\b通道发送给APNs。 关于APNs的一点新的体会这里主要谈谈这次完整了解APNs相关服务后，发现之前没有正确理解的问题。APNs提供的服务包括QoS，存储和转发，合并通知。QoS不用说了，是保证通信安全的一个标准。而这里的存储和转发有一点细节的问题，在Provider已经将Notification发送给APNs时，如果APNs发现目标用户设备处于下线状态，则会将这条通知存储一段时间，在用户处于上线转台的时候立马推送给用户。这里的存储有一个特性，\b该服务只会存储最新的通知，这就导致了对一个处于下线状态的用户再次推送通知会导致之前的通知(下线状态收到的)会被丢弃掉。同时，如果超过一定的时间，APNs会把之前\b保存的通知全部丢弃。APNs还提供了合并多调通知的功能。具体的操作方法是在发送HTTP请求的时候，有一个名为 apns-collapse-id 的字段，APNs会自动将该字段取值相同的Notification合并成一条再推送给设备。 APNs的安全措施为了保证APNs服务的可靠性，APNs强制使用端到端服务，加密验证\b以及双层认证。双层认证分别为： \b连接认证 Provider-APNs连接认证： Provider和APNs想建立可靠连接，需要Provider遵循SSL证书或者token授权证书。这两种证书都可以在Apple开发者官网上进行申请。 APNs-设备连接认证： 设备的token信息是一个\b封闭的NSData数据，只有APNs可以解析其内容。每一个APP在注册到APNs的时候都会获得一个唯一的token用于通信，在之后的每一次推送通知的请求中都需要携带这个token作为标志。 设备令牌认证 Provider-APNs可靠性 Provider与APNs之间的通信可靠性可以用两种方案来实现。分别是基于token的连接认证和基于证书的连接认证。 1. 基于token的连接认证 简单解释下上图中的通信流程： Provider通过TLS向APNs请求建立一个安全可靠的链接； APNs返回给Provider一个APNs证书，标识该Provider是有效的。到这一步为止，连接已经建立完成； Provider发送通知推送请求，请求里面需要携带token； APNs验证Provider发送过来的token，回应推送请求。 2. 基于证书的连接认证​大致的流程： Provider通过TLS向APNs请求建立一个安全可靠的链接; APNs返回一个证书，连接建立完成； Provider发送一个Apple-provisioned provider certificate(可以通过开发者网站申请)给APNs； APNs对发过来的Apple-provisioned provider certificate进行验证，确定跟APNs通信的Provider是可靠有效的，因此建立连接。 APNs-设备连接认证与设备token需要注意的一点是：APNs和每一个设备的认真连接是自动建立的。每一个设备都一份属于自己的加密证书和一个私钥。通信流程大致如下图所示：建立的流程比较简单，就不在赘述了。在TLS连接建立完成后。在当前设备上所有的APP都能够通过注册到APNs的方式来获取属于当前APP的特定token用于远端推送通知。在获取到设备token之后，APP需要将获得的Token发送给相关的Provider。Provider(通知后台)需要token来跟APNs和目标设备通信。token在三端之间的传递流程如下图所示： 首先将APP注册到APNs上。如果当前的APP已经注册过，并且APP对应的Token没有发生改变的话，系统会快速返回之前的Token并直接跳到第4步。 如果需要新创建一个设备Token，APNs通过设备的证书里面包含信息生成一个新的Token。然后将其发送给对应的设备。 通过代码获取到APP对应的Token，调用 1- (void)application:(NSApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken; APP将拿到的Token通过HTTP请求发送给Provider 在整个消息推送流程中Provider到设备的路径 远端通知具体内容每一个远端通知都有一个保存的内容的负载，其负载大小的容量随通知的类型而定。 系统要求是通常类型的通知内容，大小不能超过4KB；语音形式的内容(VoIP)，大小不能超过5KB。 (如果发送的请求消息体容量超过限制，APNs会拒绝接受这条通知。此外，通知消息本身是不会有保护或者加密措施的，因此关于客户的敏感信息最好不要放在推送通知里面进行传递。） 一个典型的通知内容JSON123456{ \"aps\" : { \"alert\" : \"Message received from Bob\" }, \"acme2\" : [ \"bang\", \"whiz\" ]}//aps字段是通知中最重要的字段，该字段用于确定接收通知的系统该如何提醒用户。//acme2里面存放的是自定义数据。 下面是一个复杂一点的通知体 123456789{ \"aps\" : { \"alert\" : \"You got your emails.\", //通知的title \"badge\" : 9, //将APP的icon右上角的红色提醒标记为9 \"sound\" : \"bingbong.aiff\" //播放名为bingbong的提示音 }, \"acme1\" : \"bar\", \"acme2\" : 42} ###构筑一个后台更新通知 后台更新通知通过定期唤醒您的应用程序，以便在后台刷新其数据，从而改善用户体验。这种后台通知既可以显示的提醒用户，也可以静默地在后台完成工作。那么如何使用这种通知呢？ 具体的做法是： 在aps字段中添加content-available字段，并且设置其值为1; 系统在接到后台通知后，会通过application:didReceiveRemoteNotification:fetchCompletionHandler:通知APP。使用该方法来进行界面的更新操作。 在后台处理远程通知需要开发者将相应的背景模式添加到APP的配置中： 选中工程文件； 选中对应的Target； 选中Capabilities选项； 打开Background Modes； 选中 Remote notification模式； 背景通知的范例：1234567{ \"aps\" : { \"content-available\" : 1 }, \"acme1\" : \"bar\", \"acme2\" : 42} 本地化远端通知(多语言问题)本地化远端通知有两种方式： 从后台服务器上提供本地化的内容； 在APP bundle里面存放一个本地化字符串； 其中第一条比较简单，就不多做解释了，就是语言问题放在服务器后台去处理。 第二种简单介绍下，在本地创建一个 Localizable.strings文件，比如写上这么一句： 1GAME_PLAY_REQUEST_FORMAT\" = \"%@ and %@ have invited you to play Monopoly\"; 搭配下面这个通知体： 123456789{ &amp;quot;aps&amp;quot; : { &amp;quot;alert&amp;quot; : { &amp;quot;loc-key&amp;quot; : &amp;quot;GAME_PLAY_REQUEST_FORMAT&amp;quot;, &amp;quot;loc-args&amp;quot; : [ &amp;quot;Jenna&amp;quot;, &amp;quot;Frank&amp;quot;] } } }{ \"aps\" : { \"alert\" : { \"loc-key\" : \"GAME_PLAY_REQUEST_FORMAT\", \"loc-args\" : [ \"Jenna\", \"Frank\"] } }}//会根据loc-key来找到对应的本地文案进行替换。 就能够实现远端通知搭配本地保存的Strings进行最终显示。","link":"/2018/01/02/Apple Programming Guide/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"JSP","slug":"JSP","link":"/tags/JSP/"},{"name":"RN","slug":"RN","link":"/tags/RN/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Lua","slug":"Lua","link":"/tags/Lua/"},{"name":"图像处理","slug":"图像处理","link":"/tags/图像处理/"},{"name":"OC","slug":"OC","link":"/tags/OC/"},{"name":"基础知识","slug":"基础知识","link":"/tags/基础知识/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"软件测试","slug":"软件测试","link":"/tags/软件测试/"}],"categories":[{"name":"iOS","slug":"iOS","link":"/categories/iOS/"}]}
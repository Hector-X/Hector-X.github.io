{"pages":[],"posts":[{"title":"类的动态内存分配","text":"构造函数使用new的类 对于指向内存是由new分配的所有类成员，都应该在类的析构函数中对其使用delete，释放其分配的空间; 如果析构函数通过delete来释放内存，则每个构造函数都应当使用new来初始化指针，或将其设置为空指针； new[] 要对应delete[],new要对应delete，不允许错位对应； 应当定义一个复制构造函数(防止编译器自己声明为默认) className(const className &amp;) 应当定义一个重载赋值运算符的成员函数，原型为： ​ ​ classname &amp; classname operator=(const classname&amp;cn){ if(this==&amp;cn) //防止指向自己被误删除 return *this; delete [] classpointer; //腾出空间 classpointer = new typeName[size]; //初始化一个新的指针 return *this; } 将结构体直接声明在class的声明文件(头文件中)头文件就是.h文件","link":"/2015/10/22/C++动态内存分配/"},{"title":"CRP(关键渲染路径)","text":"优化前端页面有几种可以用作参考的思路 压缩数据 缩小，压缩，缓存。缩小和压缩有一些成熟的自动化框架，能够让JS，CSS和HTML文件本身变得更小，下载起来速度更快； 减少关键资源数 减少可能阻止渲染的资源：（CSS必须全部加载完，才能生成渲染树，才能进行渲染显示，哪怕有些CSS不是当前需要的，比如说针对一些特殊屏幕尺寸的CSS），解决方案如下： 使用media 字段，让一些固定一些CSS的加载时机，这样可以防止部分CSS阻止渲染； 使用inline CSS，减小请求CSS文件的时间 减少可能阻止解析的资源(主要是指JS) 使用defer字段； 使用script标签的async属性，让JS异步完成加载(当且仅当页面加载不依赖JS的情况下) 缩短关键路径长度优化关键资源的加载顺序，如果关键资源过大可能需要分次请求再能完整加载，优化这个过程能够减少完整渲染页面需要的时间 (PS:浏览器可以同时下载CSS和JS文件) 我犯的错误所谓的关键资源，指的是会影响到渲染流程的资源，如果该资源不会影响到渲染，比如异步JS或者图片，那么这些资源就不能称之为关键资源，自然也不会被计算在关键路径当中 浏览器的预加载扫描器，能在拉到HTML文件的时候自动查找必须要下载的JS并且预先下载下来(preload)","link":"/2017/05/19/CRP(关键渲染路径)/"},{"title":"C++的新特性（函数篇）","text":"内联函数 内联函数的工作原理跟函数调用很像，最大的区别是函数调用需要在调用的时候转到子函数运行，而内联函数是将运行代码直接置换为内联代码直接运行的，没有跳转地址这一过程,可以节省效率。 使用内联函数需要注意的几点： 内联函数的声明和定义都要在前面加上inline； 内联函数的声明和定义都要同时完成； 内联函数不能递归 子函数代码多的不适合写作内联函数。 使用举例：inline double square(double x) {return x*x}; 引用变量 引用变量相当于创建一个变量的别名，以后使用这个变量就相当于使用原变量，他们两个内容相同，地址相同，只是名字不同(相当于一个变量有了两个名字)。 创建引用变量：举例 int rats; int &amp; rodents=rats;rodents就变成了rats的引用变量 引用变量与指针相似但是用法与指针有很大差别。指针能够先声明再赋值，但是引用变量必须在声明的同时初始化 将引用用在函数传递参数的过程中，引用要求比一般传递严格，必须要求被引用的变量是能用地址访问的值，如表达式就不能用引用变量的形式进行传递，例如，对于sum(int) 和sum(int &amp;)来说，前者可以用sum(x+1)而后者sum(x+1)是不合法的。一般来说，如果实参与引用参数不匹配，C++将生成临时变量。当前标准下，只有参数为const引用的时候C++才允许这样做。 左值：指可以被引用的数值对象（那些能够通过地址访问的值） 右值：字面常量，多项式表达式这些不能用地址访问的。 引用可以用于结构，还可以用于类对象，用类创建引用就好，例如：（ostream &amp; a），它可接纳fstream和ostream的实参(因为类继承的缘故，引用也可以一并继承) 何时使用引用参数： 目前我们已经知道主要由三种传值的方法：实值传递，指针传递，引用传递。那么在不同的情况下如何正确的使用这三种方法，以下是指导。 对于不修改的值 如果数据对象很小，如内置数据类型或小型结构，则按值传递。 如果对象是数组，那只能使用指针。 如果是较大的结构，使用const指针或const引用，节省赋值结构体所需的时间。 如果数据对象是类，那直接使用引用。 对于要修改的值 内置数据类型,数组只能用指针。 结构用指针或引用。 类直接用引用； 默认参数 默认阐述就是在声明函数原型时候给里面的形参规定好初始值。 默认参数的设置只能从右到左，不允许跳过。例如： double sum(double a,double b=2,double c) // 这是不合法的形式，应该如 double sum(double a,double b=2,double c=3) //这是合法的形式","link":"/2015/10/14/C++新特性/"},{"title":"ES6笔记","text":"let声明的变量只存在于当前的代码块中; 变量提升：在变量声明前面使用，会变成Undefined而不会报错； ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。对象使用花括号表达的 对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。 默认值生效的条件是，对象的属性值严格等于undefined var {x = 3} = {}; x // 3 var {x, y = 5} = {x: 1}; x // 1 y // 5 var {x:y = 3} = {}; y // 3 var {x:y = 3} = {x: 5}; y // 5 var { message: msg = &apos;Something went wrong&apos; } = {}; msg // &quot;Something went wrong&quot; 如果要将一个已经声明的变量用于解构赋值，必须非常小心。因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。 JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 字符串扩展:反引号表示模板字符串，在其中可以用${}来放变量，表达式，甚至是放函数。例如 ${func()}","link":"/2016/07/26/ES6笔记/"},{"title":"JSP","text":"在mac上启动Tomcat的时候要在终端中使用sudo ./startup.sh HTML中的注释语是&lt;!--这里写你的注释--&gt;(惊奇的发现MarkDown也吃这一套，果然标记语言出身) &lt;form&gt;&lt;/form&gt;是包含哪些能够将数据上传到互联网服务器的交互指令的，是HTML的语法，具体用例&lt;form action=&quot;main.jsp&quot; method=&quot;GET&quot;&gt;其中的GET是一种传输数据的方法！","link":"/2015/11/23/JSP/"},{"title":"整理下安装hexo时遇到的问题","text":"かぼちゃの皮の砂糖煮 by チャイ on pixiv 我的系统是OSX10.10.5，装hexo首先要装git和node。这两样东西用官网的安装包安装就好了，至少我并没有使用nvm，也并没有报错，安装的时候可能因为权限不够，指令前面加上sudo就好。 首先需要注意的是.config.yml文件的配置一定要在冒号后面空格，如果没有空格hexo的指令可能无法正常执行； 当前的hexo采用的基本都是git来部署到github上，所以在deploy那一栏要填git而不是github，并且事先要在系统里预装对应的部署文件，详见hexo的部署页面 我遇到问题主要是$ hexo deploy这条指令执行以后没反应，重新安装部署文件后问题得到了解决。 需要注意的是mac系统下没有windows的git bash那么方便，务必先要cd到hexo安装目录下才能够运行hexo对应的指令. 在编写博客的时候，我发现使用$ hexo new &quot;文件名&quot;指令生成的文件直接撰写的话，并不能提交到hexo上面去，我仿照自带的md文件将时间项和TAG删去以后才能够正常发布，不知道是什么原因，找时间研究一下。","link":"/2015/10/08/hexo安装问题/"},{"title":"RN笔记","text":"ListView组件有两个必需的属性：dataSource和renderRow。dataSource即为列表内容的实际数据来源。renderRow则根据数据渲染实际内容。 pop 回传参数:如果你需要传递数据到上一个页面，我建议的方式是上一个页面push过来时通过参数传第一个 callback 函数，手动 pop 之前通过回调上一个页面传过来的 callback 回传参数 自定义 NavigationBar 默认返回按钮返回事件有可能要在返回之前做一些事情，只需要在Page子类里面实现pop方法，在处理完事情后调用super.pop()即可。","link":"/2016/07/27/RN笔记/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 1let hello = new Object() test objc code1[self viewDidLoad]; 1let ha = '1111'","link":"/2019/03/03/hello-world/"},{"title":"iOS中防止SQL注入","text":"因为runtime的特性，iOS存在SQL的注入，这是由于SQL的特性所示。 SQL规定:如果在语句中存在单引号’ 那么会将SQL语句阶段，分解成两段SQL语句进行执行。 反注入的通常做法是， 利用SQLite的绑定参数。通过绑定参数避免字符串拼接。1234- (BOOL)insertMessage:(NSString*)message{return [db executeUpdate:@&quot;INSERT INTO message VALUES(?)&quot;, message];} 对于不适用绑定参数的SQL，则可以将~传入参数~的单引号替换成双单引号，避免传入的单引号提前截断SQL。123456- (BOOL)insertMessage:(NSString*)message{NSString * sql = [NSString stringWithFormat:@&quot;INSERT INTO message VALUES(&apos;%@&apos;)&quot;, [message stringByReplacingOccurrencesOfString:@&quot;&apos;&quot; withString:@&quot;&apos;&apos;&quot;]];return [db executeUpdate:sql];} 举个🌰，上述函数如果传入的message字符串为” ` delete x from table”的话，SQL语句会被截断为先insert，再delete，这就是典型的SQL注入！","link":"/2017/09/16/iOS中防止SQL注入/"},{"title":"iOS渐变动画","text":"本文对iOS的渐变动画做一个简单的整理。代码如下： 1234567CATransition *transition = [CATransition animation]; transition.type = kCATransitionFade; transition.duration = 1.0f; transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; [currentVehicleImage.layer addAnimation:transition forKey:nil]; //到此已经将渐变动画插入到了对应ImageView的图层里面 currentVehicleImage setImage:[UIImage imageNamed:[self.vehicleTypeArray objectAtIndex:itemofVehicle]]];","link":"/2016/07/19/iOS渐变动画/"},{"title":"iOS的cell重用模式","text":"这种机制下系统默认有一个可变数组NSMutableArray * visiableCells,用来保存当前显示的cell.一个可变字典NSMutableDictnery* reusableTableCells,用来保存可重复利用的cell.(之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell). 系统第一次执行- (UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath这个方法的时候, reusableTableCells为空,[tableView dequeueReusableCellWithIdentifier:identifier]的返回值为nil,我们需要通过[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]方式来创建. 但是当整个屏幕的cell显示不完全的时候cellForRowAtIndexPath这个方法的执行情况是： 先执行[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]创建整个屏幕能显示的cell数+1的cell(当我们拖动UITableView的时候,第一个cell没有移出屏幕,最下面的cell就已经存在),并指定相同或者不同的标示符identifier.把创建出的屏幕能显示的cell全部都加入到visiableCells数组中(最后一个创建的先不加入数组)，reusableTableCells为空. 当我们拖动屏幕时,顶端的cell移出屏幕并加入到reusableTableCells字典中,键为identifier ,并把之前已经创建的但是没有加入到visiableCells的cell加入到visiableCells数组中. 当我们接着拖动的时候,因为reusableTableCells中已经有值，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用，执行[tableView dequeueReusableCellWithIdentifier: identifier]，返回一个标示符为identifier的cell。该cell移出reusableTableCells之后加入到visiableCells；顶端的cell移出visiableCells并加入到reusableTableCells.如果visiableCells数组中没有找到identifier类型的cell,则再次重新alloc一个.复用的逻辑就来自于不断的将可以复用的cell从reusableTableCells中取出并加入到visiablecells**中 12//在iOS6之后系统加入了一种单元格注册的方法.[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier: identifier] ; 这个方法的作用是：当我们从重用队列中取cell的时候,如果没有,系统会帮我们创建我们给定类型的cell,如果有,则直接重用. 这种方式cell的样式为系统默认样式.","link":"/2017/07/08/iOS的cell重用模式/"},{"title":"iOS设计模式","text":"本文对iOS中经常使用的设计模式做一个整理。 适配器（Adapter）模式适配器可以让一些接口不兼容的类一起工作。它包装一个对象然后暴漏一个标准的交互接口。 如果你熟悉适配器设计模式，苹果通过一个稍微不同的方式来实现它，苹果使用了协议(Protocol)的方式来实现。你可能已经熟悉UITableViewDelegate, UIScrollViewDelegate, NSCoding 和 NSCopying协议。举个例子，使用NSCopying协议，任何类都可以提供一个标准的copy方法。 delegate要声明成weak，这是因为在做调用处理的时候为了防止循环引用的发生！id意味着delegate属性可以用任何遵从HorizontalScrollerDelegate的类赋值，这样可以保障一定的类型安全。 备忘录 模式备忘录模式快照对象的内部状态并将其保存到外部。换句话说，它将状态保存到某处，过会你可以不破坏封装的情况下恢复对象的状态，也就是说原来对象中的私有数据仍然是私有的。其实就是iOS的本地化，可以用UserDefault来进行状态的暂存，然后在重新唤起APP的时候读取到正确的状态 归档（Archiving）归档是苹果对于备忘录模式的特定实现之一。这种机制可以转换一个对象到一个可保存的数据流中，过会可以在不暴漏私有属性给外部的情况下重建它们 命令 模式 将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。命令模式将一个请求封装为一个对象。封装以后的请求会比原生的请求更加灵活，因为这些封装后的请求可以在多个对象之间传递，存储以便以后使用，还可以动态的修改，或者放进一个队列中。苹果通过Target-Action机制和Invocation实现命令模式。 外观 模式 外观模式针对复杂的子系统提供了单一的接口，不需要暴露一些列的类和API给用户，你仅仅公开一个简单统一的API。 个比较好理解哦 只在头文件中暴露必要的接口，隐去大部分的内部逻辑 装饰器 (Decorator) 模式 装饰器模式在不修改原来代码的情况下动态的给对象增加新的行为和职责，它通过一个对象包装被装饰对象的方法来修改类的行为，这种方法可以做为子类化的一种替代方法。这个更简单了，就是分类嘛。分类和代理都可以，都算在不修改原类的基础上动态的添加方法！ 迭代器 模式 提供一个外部的方法访问容器对象的各个元素，又不需要暴露该容器对象的内部表示iOS中的实现有NSEnumerator 1234567NSArray *anArray = @[@\"this\", @\"is\", @\"a\", @\"test\"];NSEnumerator *itemEnumerator = [anArray objectEnumerator];NSString *item;while (item = [itemEnumerator nextObject]) { NSLog(@\"%@\", item); } 还有一种方法不用whie手动控制，直接用Block作为访问的回调,这种内部的实现方法很搞，看来是要手动设置Stop的条件，否则会一直循环下去12345678NSArray *anArray = @[@\"this\", @\"is\", @\"a\", @\"test\"];NSString *string = @\"a\";[anArray enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { NSLog(@\"%@\", obj); if ([obj isEqualToString:string]) { *stop = YES; } }]; 组合 模式 组合模式将对象组合成树形结构以表示”部分-整体”的层次结构。组合使得用户对当个对象和组合对象的使用具有一致性iOS中的典型代表是UIView，对单个UIView的操作和对复合型UIView的操作是一致的。","link":"/2017/07/07/iOS设计模式/"},{"title":"Mac下搭建JSP的开发环境","text":"因为需要做一个JSP的工程项目，所以开始寻找一些方便开发的工具，走了很多弯路。一开始用的是Tomcat+文本编辑器的方式，但是发现Tomcat并没有自动帮我生成class文件的目录，造成自己编写的包文件并没有产生其应当产生的作用，这点让我很苦恼。然后使用了朋友推荐的MyEclipse，发现其在mac下的发挥并不好，容易产生很多bug，类似于修改了jsp内容编译后仍然报原来内容的语法错误等。最后在Eclipse官网上寻找到了[Eclipse IDE for Java EE Developers][1],下载下来以后使用了一下非常的便捷，而且非常稳定，容量也很小，比起myEclipse轻便太多，也没有出现我之前遇到过的问题。 在该软件中创建Project->Dynamic web project(在创建的时候就提示你配置server,我们可以点击add按钮，然后选择Tomcat,目录到之前下载解压文件的位置) 同时在下面的选项中选择JDK的版本。 点击运行按钮，会弹出服务器设置，可以看到之前设置的Tomcat的服务器已经在里面了，我们选中默认，之后再运行就能够自动打开浏览器。 1]: %22http://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/mars1%22","link":"/2015/11/23/mac下的JSP/"},{"title":"代码高亮测试","text":"1[self viewWillDisapper] 123{ 'key':'xujian' }","link":"/2018/07/04/代码高亮测试/"},{"title":"iOS View和Layer的区别","text":"每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为) layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer 两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以 两者的关系其实说白了UIView和CALayer之间的关系就是MVC的关系，UIView就是C，CALayer就是M，负责绘图单元的笼统来说就是V。 ①当绘图单元需要绘制CALayer的时候，会拿到被标记为需要绘制的CALayer渲染树的值，以及要显示图片，进行像素合成。②CALayer自身有个delegate，设置的是UIView， 当CALayer被绘制时会执行delegate方法通知UIView，看看UIView是有提供需要绘制的元素。③如果UIView什么都不需要提供，就当作无视。 ①当你修改UIView的frame.size.width之后，UIView实际上是会把你修改的值映射到CALayer上去，让CALayer知道修改了什么。②CALayer获取到要修改的值，然后去更新CALayer的模型树，呈现树，渲染树，准备好了渲染树。③等绘制单元要绘制到这个CALayer的时候就会按照渲染树的值渲染到屏幕去。 不一样的UIView层次和CALayer层次UIView和CALayer有各自不一样的职责，那么他们的树也同样的有各自不一样的职责，CALayer之前说得比较清楚了，他的职责是存储数据，那么所以CALayer树的职责就是存储数据的树，以供你修改,做动画和渲染等使用。UIView树的话，先看UIView继承了什么，UIView继承了UIResponder，UIResponder是负责一些触摸事件的类，所以UIView树主要的职责就是做触摸的传递，这个工作可以分为2部分，1部分是寻找你点击到的那个view，另外一部分是把你的触摸方法传递下去。在这里的话UIView树其实是充当了责任链职责。 presentationLayer(展示树)的作用这个问题回答完了，就是因为在做动画的时候，需要把过渡的位置显示出来，而不是迅移，人类眼睛留下了残影才可以看到有动画。所以需要一个presentationLayer来存放这些过渡的数据，然后再这些过渡数据一个个渲染出来（其实就是每一帧）。那么可以看出来presentationLayer是为做动画服务的（其实有没为其他服务我就不知道了）。所以假如在做动画的时候，presentationLayer里面的值就是当前屏幕的值；而modelLayer的值就是动画结束后的值。 模型树，呈现树，渲染树iOS的显示是经历了三个树状结构，才显示到了屏幕上：模型树–&gt;呈现树–&gt;渲染树 通常，我们操作的是模型树，在重绘周期最后，我们会将模型树相关内容（层次结构、图层属性和动画）序列化，通过IPC传递给专门负责屏幕渲染的渲染进程。渲染进程拿到数据并反序列化出树状结构–呈现树。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现图层的值来获取当前屏幕上真正显示出来的值。我们可以通过CALayer的-presentationLayer方法来访问对应的呈现树图层。注意呈现图层仅仅当图层首次被提交（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用-presentationLayer将会返回nil。你可能注意到有一个叫做–modelLayer的方法。在呈现图层上调用–modelLayer将会返回它正在呈现所依赖的CALayer。通常在一个图层上调用-modelLayer会返回–self（实际上我们已经创建的原始图层就是一种数据模型）。 presentLayer和modelLayer的关系在CALayer内部，它控制着两个属性：presentationLayer(以下称为P)和modelLayer（以下称为M）。P只负责显示，M只负责数据的存储和获取。我们对layer的各种属性赋值比如frame，实际上是直接对M的属性赋值，而P将在每一次屏幕刷新的时候回到M的状态。比如此时M的状态是1，P的状态也是1，然后我们把M的状态改为2，那么此时P还没有过去，也就是我们看到的状态P还是1，在下一次屏幕刷新的时候P才变为2。 CAAnimation的实现原理而当一个CAAnimation（以下称为A）加到了layer上面后，A就把M从P身上挤下去了。现在P背着的是A，P同样在每次屏幕刷新的时候去问他背着的那个家伙，A就指挥它从fromValue到toValue来改变值。而动画结束后，A会自动被移除，这时P没有了指挥，就只能大喊“M你在哪”，M说我还在原地没动呢，于是P就顺声回到M的位置了。这就是为什么动画结束后我们看到这个视图又回到了原来的位置，是因为我们看到在移动的是P，而指挥它移动的是A，M永远停在原来的位置没有动，动画结束后A被移除，P就回到了M的怀里。动画结束后，P会回到M的状态（当然这是有前提的，因为动画已经被移除了，我们可以设置fillMode来继续影响P），但是这通常都不是我们动画想要的效果。我们通常想要的是，动画结束后，视图就停在结束的地方，并且此时我去访问该视图的属性（也就是M的属性），也应该就是当前看到的那个样子。按照官方文档的描述，我们的CAAnimation动画都可以通过设置modelLayer到动画结束的状态来实现P和M的同步。 render Tree(渲染树)render tree 是系统用来绘制动画的tree，不需要理会。系统自己实现对应的功能","link":"/2017/09/12/iOS View和Layer的区别/"},{"title":"通过2D图像创建3D模型","text":"步骤 首先采集照片(目前只考虑一张平面照片的实现) 将图像二值化再经过高通滤波，这样人体模型只剩下轮廓，方便采点(需求貌似只是手工采点)。 当务之急是看懂映射的代码 通过论文建议采的点是：头顶，颈点(脖子跟肩膀的连接处)，肩点，腋窝，手掌端点(人体手臂的最远处)，胯部(人体下肢的分叉处)，膝盖，足(整个图像的最低点，一对)，胸侧(一对)，腰侧(一对) 下面是采点的示意图","link":"/2015/11/26/图像重构/"},{"title":"子View和父View的触摸事件传递机制","text":"关于iOS中子View和父View之间的touch时间传递关系整理。 消息传递如果在父View中添加子View，然后在父View的m文件中描述touchBegin函数的时候，会发生触摸子View的区域TouchBegin事件没有响应。 这是因为子View把触摸事件截获了，但是在没有做任何响应链处理的情况下，子View是不会把触摸事件传回父View的。这个时候我们需要为子View写一个Category来完成事件链的传递。 下以子UIView为例。 创建一个类别，command+N选择OC文件然后在下拉菜单中选category。命名为Touch,Class选择UIView. 在m文件中添加如下代码：123456789101112131415- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [[self nextResponder] touchesBegan:touches withEvent:event]; [super touchesBegan:touches withEvent:event];}-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event { [[self nextResponder] touchesMoved:touches withEvent:event]; [super touchesMoved:touches withEvent:event];}- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent*)event { [[self nextResponder] touchesEnded:touches withEvent:event]; [super touchesEnded:touches withEvent:event];} 注意：如果有多层的嵌套View,那每一层的View都要做同样处理 PS：如果想让ScorllView隐藏滚动条： 1cell.scrollerView.showsHorizontalScrollIndicator = FALSE;//隐藏横向的滚动条","link":"/2016/07/18/子view和父view的触摸事件传递机制/"},{"title":"图像处理","text":"遊びに行こうよ by ポ～ン（出水ぽすか） on pixiv #任务 直方图计算 计算并绘制直方图 直方图的均衡化 直方图的计算和绘图都不能使用opencv里面已经提供的函数，要自己通过C++编写。 直方图的均衡化原理很好理解，同时又由于图像的灰度值是离散的，所以只要按照顺序把每个灰度值的出现概率累加就很容易能够得出均衡后的灰度直方图，然后再映射到图像上输出就可以了。 为了能用更加简单的原理实现这个功能，我采用了现将图像转换成二维数组（这点在matlab中非常方便，因为matlab读取图像就是以二维矩阵的方式保存的）。然后使用二维数组完成均衡化的计算，最后再利用opencV里的一个类将结果二维矩阵转化成图像打印。 画图函数采用了cv库函数里面的rectangle函数，只要知道对角点的坐标就可以画出对应的矩阵，就这样一个一个矩阵的画出直方图。 附上源代码( 密码: 5qvd)","link":"/2015/10/10/数字图像处理/"},{"title":"lua","text":"lua简明语法 字符串连接符 .. 例子：”a”..”b” 将数字转成字符串 tostring 将字符串转成数组 tonumber 如果单引号’双引号”要打印出来的话。在符号的前面加上反斜线\\,例如\\” 还可以用[[ ]]的方式来代替引号引用，而且不用\\来转义。 lua的转义字符继承自C，例如\\n的意思是回车 获取字符串的长度，在变量或者字符串前直接使用#，或者string.len(string) eg. print(#string) 运算符：and or not 代替C中的&amp; | ! nil表示没有值！ 手动创建域（block） 以do开头，end结尾，block中的变量对外部是不可见的（声明的局部变量前面要加local关键字） 定义函数：(如果要将函数定义为局部函数，在最开头的位置写上localf关键字)（参数和返回值的逻辑都是按照C的语法写的）lua原生语法是： hello()=function{ print(&quot;Hello,world!&quot;) } 但是也可以简化为: function hello(){ ... } end 函数也能作为一个整体的值来用==，~=（不等于）比较，得到一个bool的结果if条件的语法：(支持elseif 和 else 同级别的条件判断只需要一个end,在嵌套的时候有几层就有几个end) if&lt;条件&gt;then --body end 注意：lua中的输出不用写出类型，直接用..连接符，如print(“The number is”..num) while循环​ while&lt;条件&gt;do --body end repeat循环（相当于C中的do while，先执行再判断，至少执行一次）​ repeat --body until&lt;判断条件&gt; for循环 for 变量名=起始值，终点值，步进 do （默认的步进是1） --body end （计数变量名的作用域会被自动地设置为局部的，在层外不可访问）如果想要保存循环中的量，在for循环前面设置一个局部变量，就可以存放要保存的数字。 upper=10 do local max for i=1,upper do max= i end print(max) 这里打印出来的值也仍然是10 end 表（table）接近于C++中的map，OC中的NSDictionaryLUA的表的下标是从1开始算的，不是0创建索引表 ： name={}初始化索引表： name[key]=value （其中的key和value可以为任意类型的数据）清除元素：name[key]=nil字符串作为key的时候有更简便的形式：之前alice[&quot;address1&quot;]=&quot;114&quot;等于现在的alice.address=&quot;114&quot;创建有内容的表myTable={[key1]=value1， 也可以写成key1=value1（LUA简化写法）[key2]=value2，}（Lua在最后一个元素的后面也要写逗号，这与其他语法不同，记住！） 可以把table当做数组使用，声明方法name={val1,val2,val3,}去数组长度的方法仍然是#name插入元素，name.insert(table,pos, value) 表，位置（可选参数，如果没有插入表尾），值删除元素 ，name.remove(table,pos)排序 name.sort(table,compare) compare可选参数，默认是升序 工厂函数就是在每次调用的时候都返回一个新的对象。 利用元表对表进行扩展元表metatable，可以附加到现存表上定义一些功能和行为，例如： function mt.__add(a,b) //__add（）是内置的原方法，可以在官网查到 //本句是将该方法注册到mt这个表内。（表内可以放函数） local result=setmetatable({},mt)//setmetatable设置元表，第一个 参数是被设置的，第二个是元表 for i=1,#a do table.insert(result,a[i]) end for i=1,#b,do table.insert(result.,b[i]) end return result end 要点：setmetatable的函数只返回一个参数，即作为第一个参数传入的表。getmeatatable()函数来检验元表是否已经成功建立，这个函数将表作为第一个参数，返回一个元表，当没有元表的时候，它返回nil（一般来说getmetatable只需要一个元表）","link":"/2015/12/02/lua/"},{"title":"理解OC的消息传递机制","text":"OC语言是C语言的超集，其实底层的函数实现还是用C些的。 id returnValue=[someObject messageName：parameter]; 其中的someObject又叫接收器(receiver)，messageName叫选择器(selector)，选择器和后面的参数合成为『消息』,OC的函数调用过程(C语言中的说法)其实是『消息传递』的过程。","link":"/2015/12/16/理解OC机制/"},{"title":"软件质量管理","text":"软件质量管理体系 全面软件质量管理(TQM)： 统计分析表 分层法：把收集来的原始数据按照一定的目的和要求加以分类整理。 散布图：强正相关；非线性相关； 因果图（鱼骨图）：一种逐步深入研究和讨论质量问题的图示方法。以结果为特性，以原因为因素，在它们之间用箭头联系表示因果关系。 控制图 帕累托图 直方图","link":"/2016/06/02/软件质量管理/"},{"title":"编译原理相关","text":"编译环节中的链接环节。其实就是把各个函数存放的代码文件编译成的o文件链接起来，用汇编指令的jump来进行跳转。我们知道函数调用对应到汇编其实是 jump 指令，后面写上被调用函数的地址，但在生成 main.o 的过程中，strlen() 函数的地址并不知道，所以只能先用 0 来代替，直到最后链接时，才会修改成真实的地址。 链接器就是靠着重定位表来知道哪些地方需要被重定位的。每个可能存在重定位的段都会有对应的重定位表。在链接阶段，链接器会根据重定位表中，需要重定位的内容，去别的目标文件中找到地址并进行重定位。 —————&gt;这就是静态编译 动态链接这个名词，它表示重定位发生在运行时而非编译后 -&gt; 这个就是动态编译 clang就是一个著名的编译前端 -&gt; 将高级代码转换成中间代码LLVM 是编译后端 -&gt; 将中间代码转换成CPU能理解的汇编代码 解释性语言不需要编译，直接由解释器执行，整个过程变成了：源代码 -&gt; 解释器 -&gt; 运行结果 因此，解释型语言和编译型语言的根本区别在于，对于用户来说，到底是直接从源码开始执行，还是从中间代码开始执行。 c语言的编译器使用C语言自己写出来的这个神奇的属性叫自举（Bootstrap） 所以一门语言能不能自举，主要取决于它的实现形式能否被编译并留下二进制格式的可执行文件。 Node.js某种程度上可以说一种JavaScript的解释器 Python之于iOS 如果是在 iOS 应用里，由于 iOS 系统没有对应的动态库，所以需要把 Python 的解释器打包成一个静态库并且链接到应用中。 解释性语言的低效解释器语言的低效是因为解释器往往会重复性的解释同一段指令，为了解决这个问题，采用JIT技术(Just in time)基于猜测缓存一些已经解释过的指令，能够提升速度 webAssembly 这个就是让JS能够仿照C++一样，在写代码的过程中提供一些前置的标记，这些标记能够让解释器提前对一些模块进行编译并缓存，提升语言的执行效率","link":"/2017/07/11/编译原理相关/"},{"title":"Swift","text":"Swift是一门类型安全的语言，会在类型没有明确指明的情况下自行推断类型，所谓类型安全是指，不支持隐式类型转换。 赋值let A：Int=10//常量 var A=10//变量 元组 元组：可以把多个值组合成一个复合值，集合内类型可以不一样； 元组中的元素可以用下标来访问，下标从零开始； 可以在定义元组的时候给里面的元素命名 let http20Status=(statusCode: 200,description: &quot;OK&quot;) ​ 注意语句中出现的冒号后面是一定要跟空格的。后面就可以用『点语法』来用名称访问元组中的元素； 断言 断言可以用来调试，分为两个部分，条件和输出语句，只有当判断条件为真的时候程序次啊会继续执行，否则中断并在控制台中打印出断言中的语句。 assert(age&gt;=0,&quot;The age cannot be less than zero &quot;) 断言是辅助调试的一种手段，有助于你在调试的过程中更加快速的发现问题并能提供一定的解释。 空和运算符 a??b（含义是如果a有值则用a的值，如果a没值的话就用b的值） 需要满足的两个条件：1.a一定要是个可选类型；2.b的类型必须要跟a存储值的类型保持一致。字符串 比较字符串：前缀/后缀相等，用string类型的hasPrefix()和hasSuffix()里面的参数是要比较的字符串的值。 大小写：调用方法uppercaseString,lowercaseString 数组 数组常用的方法，count,isempty,insert,removeatIndex,removelast,append; 如果需要全局访问(同时访问下标和值) 需要用到enumerate()函数。 ​ for (index,value) in enumerate(shoppingList){..} 创建空数组：var someInts=[Int](); 创建带有初始值的数组：var someInts=[Int](count:3,repeatedValue:0.0); 由于Swift的自动类型推断，有时候不需要特定制定数组中存储的数据类型。字典 字典的添加修改：可以直接用键值访问的方式修改 Dictionary[&quot;TD&quot;]=&quot;todo&quot; 也可以使用updateValue(forKey: ),注意这个函数返回的是被修改以前的值或者nil(为了方便我们判断修改是否成功) if let oldValue=airports.updateValue(&quot;DD&quot;,forKey:&quot;TD&quot;){ print(&quot;the old value is \\(oldValue)&quot;)//输出的值仍是todo，但是该键的值已经修改了 } 字典的删除：删除键值可以直接给该键赋值nil；或者使用removeValueForKey(),这个函数返回被删掉的键对应的值。 创建空字典： var namesOfIntegers=Dictionary&lt;Int,String&gt;() //如果上下文能够让编译器可以自动推断的话 namesOfIntegers=[:]//也可以用这种方式简单声明 集合也受可变性的影响，如果使用var声明，那么集合是可以修改的，如果是let则相反。 switch 每一个switch语句都不能为空，每一个switch语句都至少包含一条语句 一个case也可以包含多个模式，用逗号把它们分开 case的分支也可以是一个值的区间 case的分支也可能是一个元组，你可以利用元组让switch同时测试多个值。 如果存在多个匹配，那么执行第一个匹配到的结果 case分支的模式允许将匹配的值绑定到一个临时的常量或变量，这些量在该分支里就可以被使用了 case分支中能使用where语句来添加额外的条件 let AnotherPoint(-1,-1) switch AnotherPoint{ case let (x,y) where x==y: print() case let (x,y) where x==-y: print() case let (x,y): print() } 控制转移语句 continue：本次循环结束，开始下一次循环(并没有离开循环体) break：跳出循环体，跳出switch代码块(这里用法跟C++不同，因为这里的switch是自动跳出分支的)。由于swift的switch是不允许空分支的，所以将break写进分支里能实现忽略该分支的功能。 fallthrough(多了一个贯通)：如果需要实现从上一个分支传递到下一个分支(因为swift的switch是自动跳出的)，那么就在case分支结束的时候加上fallthrough(代替原来的break)，这能保证switch顺序执行判断,进入所有满足条件的case。 return","link":"/2016/01/13/赋值/"},{"title":"也说说面试的经历吧","text":"这个3，4月份在紧张的找实习，因为自己的水平不是太高，所以找的比较辛苦。如果是一般的公司笔试，基本上之前好好准备就能够解决，很多是偏向数据结构和语言比较基础的是指。面试题主要问项目，如果项目不太多的话就会加问一些数据结构的问题(链表部分是重点)，所以需要提前开始刷机试题和复习数据结构算法。 其次就是在做项目的时候要积累总结，将收获的东西以文字的方式记录下来，后面面试的时候也有可能会被问到。 找到了携程的实习，希望能对自己有很多提高#^_^#","link":"/2016/06/04/面试/"},{"title":"Effective OC","text":"阅读高效编写OC程序一书的笔记 尽量使用前向声明，在必须要import别的头文件的时候，应该尽可能的保证import的头文件大小最小(解决此问题的方法在于分开编写头文件，让每个头文件只负责自己的功能，切记不要把多个类的声明都编写在同一个头文件中) 前向声明： @property (notamic,copy) NSString *firstName; @property (notamic,copy) NSString *lastName; @property (notamic,copy) EOCEmployeer *person； 这个例子中的EOCEmployeer是另外声明的一个类，但是此刻我们只需要知道这个名字代表一个类就可以了，不需要知道里面的细节。我们就可以使用前向声明的方法，@class EOCEmployeer;让编译器知道这是个类名，但却不用调用EOCEmployeer本身的头文件。. 尽可能的使用字面量语法，这种语法很想C++中的列表初始化，原来初始化NSNumber类型的数据可能要这么写 NSNumber *num=[NSNumber numberWithInt:1]; NSNumber *num=@1;//字面量语法 值得注意的是，nil不能出现在字面量语法的声明语句中！ 避免使用#define，多用staic const代替。这样能够减少使用#define指令给编译过程中增加错误的可能性，需要注意的是const的位置会影响常量的声明，应该从左往右解读。​ extern NSString *const num; NSString *const num=@&quot;Value&quot;;//字面量语法 使用枚举enum类型来状态机的状态，传递给方法的选项以及状态码等值; 在处理枚举类型的switch语句中不要事先default分支，这样加入新的枚举后编译器就会提醒你Switch语句并未处理所有的枚举; 枚举会给每一个变量自动编号，默认是从0开始的，如果你给第一个变量赋值，那么后续变量对应的编号是在这个值的基础上+1，如 enum example{ a=1, b,//b=2 c,//c=3 }; 理解『属性』这一概念。 要理解『属性』这一概念，首先要弄清楚『属性』和『实例变量』的区别，按照我的理解，『实例变量』更接近变量本身的含义，而『属性』则是对『实例变量』的一种封装，相当于实例变量的一层外壳，有了这层外壳，我们可已享受到编译器自动为『属性』生成的读取器(getter)和设置器(setter)而不用自己声明。OC中默认生成的实例变量名为属性名前面即一个下滑线。如： @property (nonatomic,copy) a;//对应的实例变量就是_a,真正参与运算和赋值的是实例变量，并非属性。 属性的的参数有如下几种： nonatomic(非原子性)和atomic(原子性)：主要区别就是原子性的变量多一个同步锁的保护。 同步锁：回忆临界区的概念，同步锁是为了保护变量一次只被一个线程访问，即操作室原子的。一般来说，因为atomic需要消耗更多的内存，所以IOS开发一直都使用nonatomic。 读写权限：主要有readwrite和readonly。readwrite表示拥有setter和getter，而readonly只拥有getter。 内存管理语义：属性用于封装数据，而数据则要有『具体的所有权语义』，这一组属性仅会影响setter。有如下几种方式： assign: setter只会执行针对『纯量类型』的简单赋值操作。 strong: 『拥有关系』，保留新值，释放旧值，再将新值设置上去。 weak: 『非拥有关系』，既不保留新值，也不释放旧值，同assign相似，但是当属性所指对象遭到摧毁时，属性值也会清空。 unsafe_unretained，与assign相似，『非拥有关系』，与weak不同的是不会清空属性值。 copy: 非常常用。与strong相似，但不保留新值，只进行赋值。主要用于mutable类型的数据，主要实现属性所用的对象是『可变的』，就应该在设置新属性值的时候拷贝一份。 方法名: 如果不使用自动生成的setter和getter，可以在这里制定自己的方法名。语法为:getter=方法名 setter=方法名 @property (nonatomic,getter=isOn) BOOL switchcase; 在对象内部尽量直接访问实例变量 一般来说，直接在对象中使用使用实例变量能够有效的加快访问速度额，但是有些情况下需要保留对属性访问的格式。所以一种折衷的方案是：在写入实例变量时，通过”设置方法setter”来做，但是在读取变量值的时候，采用直接访问实例变量的方法。需要留意惰性初始化情况。 惰性初始化：指那些初始化代价较高的属性，只在第一次进行初始化，不随着变量的声明重复进行。如下例就是对brain属性进行了惰性初始化。 -(EOCBrain*)brain{//代码就是brain属性参数中的setter方法 (setter=brain) if(!brain){ _brain=[Brain new]; } return _barin; } 在惰性初始化的情况下，必须使用”getter”来访问数据，因为直接访问实例变量会跳过属性参数中的内存管理语义方法，如果没有调用”getter”就直接访问实例变量，则会看到尚未设置好的brain。因此如果使用了『惰性初始化技术』，务必要使用”getter”来读取变量。","link":"/2015/12/05/阅读高效编写oc程序一书的笔记/"},{"title":"阅读Apple Notification的心得体会","text":"Apple的Notification主要分类本地\b通知和\b远端通知(remote Notification)。其中本地通知主要是通过系统层面的控制来展示到前端界面，而Remote Notification需要APP这边推送通知的平台接入苹果统一的推送服务 Apple Push Notification service (APNs)下面是一个简单的示意图这张图上面的Provider是开发者自己需要部署的消息推送后台，Provider按照约定接入APNs以后，就能够使用部署的后台进行远端消息的推送。 为了推送一条消息，Provider需要经过一个如下的流程： 按照Apple官方给出的推送格式规则构筑内容，并构建一个包含通知内容的JSON字典； 将通知内容,全局唯一toke\bn和其他需要传递的信息放进HTTP请求。 最后将这个包含了令牌证书或者密码凭证的通过一个持久安全的\b通道发送给APNs。 关于APNs的一点新的体会这里主要谈谈这次完整了解APNs相关服务后，发现之前没有正确理解的问题。APNs提供的服务包括QoS，存储和转发，合并通知。QoS不用说了，是保证通信安全的一个标准。而这里的存储和转发有一点细节的问题，在Provider已经将Notification发送给APNs时，如果APNs发现目标用户设备处于下线状态，则会将这条通知存储一段时间，在用户处于上线转台的时候立马推送给用户。这里的存储有一个特性，\b该服务只会存储最新的通知，这就导致了对一个处于下线状态的用户再次推送通知会导致之前的通知(下线状态收到的)会被丢弃掉。同时，如果超过一定的时间，APNs会把之前\b保存的通知全部丢弃。APNs还提供了合并多调通知的功能。具体的操作方法是在发送HTTP请求的时候，有一个名为 apns-collapse-id 的字段，APNs会自动将该字段取值相同的Notification合并成一条再推送给设备。 APNs的安全措施为了保证APNs服务的可靠性，APNs强制使用端到端服务，加密验证\b以及双层认证。双层认证分别为： \b连接认证 Provider-APNs连接认证： Provider和APNs想建立可靠连接，需要Provider遵循SSL证书或者token授权证书。这两种证书都可以在Apple开发者官网上进行申请。 APNs-设备连接认证： 设备的token信息是一个\b封闭的NSData数据，只有APNs可以解析其内容。每一个APP在注册到APNs的时候都会获得一个唯一的token用于通信，在之后的每一次推送通知的请求中都需要携带这个token作为标志。 设备令牌认证 Provider-APNs可靠性 Provider与APNs之间的通信可靠性可以用两种方案来实现。分别是基于token的连接认证和基于证书的连接认证。 1. 基于token的连接认证 简单解释下上图中的通信流程： Provider通过TLS向APNs请求建立一个安全可靠的链接； APNs返回给Provider一个APNs证书，标识该Provider是有效的。到这一步为止，连接已经建立完成； Provider发送通知推送请求，请求里面需要携带token； APNs验证Provider发送过来的token，回应推送请求。 2. 基于证书的连接认证​大致的流程： Provider通过TLS向APNs请求建立一个安全可靠的链接; APNs返回一个证书，连接建立完成； Provider发送一个Apple-provisioned provider certificate(可以通过开发者网站申请)给APNs； APNs对发过来的Apple-provisioned provider certificate进行验证，确定跟APNs通信的Provider是可靠有效的，因此建立连接。 APNs-设备连接认证与设备token需要注意的一点是：APNs和每一个设备的认真连接是自动建立的。每一个设备都一份属于自己的加密证书和一个私钥。通信流程大致如下图所示：建立的流程比较简单，就不在赘述了。在TLS连接建立完成后。在当前设备上所有的APP都能够通过注册到APNs的方式来获取属于当前APP的特定token用于远端推送通知。在获取到设备token之后，APP需要将获得的Token发送给相关的Provider。Provider(通知后台)需要token来跟APNs和目标设备通信。token在三端之间的传递流程如下图所示： 首先将APP注册到APNs上。如果当前的APP已经注册过，并且APP对应的Token没有发生改变的话，系统会快速返回之前的Token并直接跳到第4步。 如果需要新创建一个设备Token，APNs通过设备的证书里面包含信息生成一个新的Token。然后将其发送给对应的设备。 通过代码获取到APP对应的Token，调用 1- (void)application:(NSApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken; APP将拿到的Token通过HTTP请求发送给Provider 在整个消息推送流程中Provider到设备的路径 远端通知具体内容每一个远端通知都有一个保存的内容的负载，其负载大小的容量随通知的类型而定。 系统要求是通常类型的通知内容，大小不能超过4KB；语音形式的内容(VoIP)，大小不能超过5KB。 (如果发送的请求消息体容量超过限制，APNs会拒绝接受这条通知。此外，通知消息本身是不会有保护或者加密措施的，因此关于客户的敏感信息最好不要放在推送通知里面进行传递。） 一个典型的通知内容JSON123456{ \"aps\" : { \"alert\" : \"Message received from Bob\" }, \"acme2\" : [ \"bang\", \"whiz\" ]}//aps字段是通知中最重要的字段，该字段用于确定接收通知的系统该如何提醒用户。//acme2里面存放的是自定义数据。 下面是一个复杂一点的通知体 123456789{ \"aps\" : { \"alert\" : \"You got your emails.\", //通知的title \"badge\" : 9, //将APP的icon右上角的红色提醒标记为9 \"sound\" : \"bingbong.aiff\" //播放名为bingbong的提示音 }, \"acme1\" : \"bar\", \"acme2\" : 42} ###构筑一个后台更新通知 后台更新通知通过定期唤醒您的应用程序，以便在后台刷新其数据，从而改善用户体验。这种后台通知既可以显示的提醒用户，也可以静默地在后台完成工作。那么如何使用这种通知呢？ 具体的做法是： 在aps字段中添加content-available字段，并且设置其值为1; 系统在接到后台通知后，会通过application:didReceiveRemoteNotification:fetchCompletionHandler:通知APP。使用该方法来进行界面的更新操作。 在后台处理远程通知需要开发者将相应的背景模式添加到APP的配置中： 选中工程文件； 选中对应的Target； 选中Capabilities选项； 打开Background Modes； 选中 Remote notification模式； 背景通知的范例：1234567{ \"aps\" : { \"content-available\" : 1 }, \"acme1\" : \"bar\", \"acme2\" : 42} 本地化远端通知(多语言问题)本地化远端通知有两种方式： 从后台服务器上提供本地化的内容； 在APP bundle里面存放一个本地化字符串； 其中第一条比较简单，就不多做解释了，就是语言问题放在服务器后台去处理。 第二种简单介绍下，在本地创建一个 Localizable.strings文件，比如写上这么一句： 1GAME_PLAY_REQUEST_FORMAT\" = \"%@ and %@ have invited you to play Monopoly\"; 搭配下面这个通知体： 123456789{ &amp;quot;aps&amp;quot; : { &amp;quot;alert&amp;quot; : { &amp;quot;loc-key&amp;quot; : &amp;quot;GAME_PLAY_REQUEST_FORMAT&amp;quot;, &amp;quot;loc-args&amp;quot; : [ &amp;quot;Jenna&amp;quot;, &amp;quot;Frank&amp;quot;] } } }{ \"aps\" : { \"alert\" : { \"loc-key\" : \"GAME_PLAY_REQUEST_FORMAT\", \"loc-args\" : [ \"Jenna\", \"Frank\"] } }}//会根据loc-key来找到对应的本地文案进行替换。 就能够实现远端通知搭配本地保存的Strings进行最终显示。","link":"/2018/01/02/Apple Programming Guide/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"JSP","slug":"JSP","link":"/tags/JSP/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"RN","slug":"RN","link":"/tags/RN/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"图像处理","slug":"图像处理","link":"/tags/图像处理/"},{"name":"Lua","slug":"Lua","link":"/tags/Lua/"},{"name":"OC","slug":"OC","link":"/tags/OC/"},{"name":"软件测试","slug":"软件测试","link":"/tags/软件测试/"},{"name":"基础知识","slug":"基础知识","link":"/tags/基础知识/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"}],"categories":[{"name":"iOS","slug":"iOS","link":"/categories/iOS/"}]}